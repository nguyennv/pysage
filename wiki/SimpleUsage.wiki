#summary simple usage

For more API documentation, see [http://bigjinfo.com/pysage/ reference]

=Tutorial=
==Simple Usage==
Let's take the code from the front page for example, and we'll go over this line by line to give you an in-depth idea what pysage is doing for you.

Here is the code:
{{{
import time
from pysage import Actor, ActorManager, Message

mgr = ActorManager.get_singleton()

class BombMessage(Message):
    properties = ['damage']
    packet_type = 101

class Player(Actor):
    subscriptions = ['BombMessage']
    def handle_BombMessage(self, msg):
        print 'I took %s damage from the bomb' % msg.get_property('damage')

mgr.register_actor(Player(), 'player1')
mgr.queue_message(BombMessage(damage=10))

while True:
    processed = mgr.tick()
    time.sleep(.03)
}}}

Here, we import pysage base classes:
{{{
from pysage import Actor, ActorManager
from pysage.messaging import Message
}}}
Next, we will create the actor manager.  Per os process (pysage group), you are guaranteed a single instance of the actor manager.  

The manager instance does all the book-keeping with actors, messages, and communication across processes/networks, so that you don't have to worry about it.  

All you will use it for is to send messages, and manage actors and groups, which we will see later.
{{{
mgr = ActorManager.get_singleton()
}}}
To create a message type, define a class that inherits from "Message".  The "properties" class variable must be defined and is a list of strings.  The list will contain a set of attributes that this type of message will carry.
{{{
class SecretMessage(Message):
    properties = ['content']
}}}
To create an actor type, define a class that inherits from "Actor".  The "subscriptions" class variable of an actor is a list of message type names that the actor will subscribe to.  For each of these message types, the actor class needs to define a method that starts with "handle`_`", and appended with the message type name.  Additionally, the "update" method of each actor will be called each time the actor manager "ticks".  We will talk about the "tick" in a bit.
{{{
class SecretActor(Actor):
    subscriptions = ['SecretMessage']
    def handle_SecretMessage(self, msg):
        print 'the secret is %s' % msg.get_property('content')
        return True # stop propagation
    def update(self):
        '''runs on every mgr.tick'''
        pass
}}}
When you are ready to create an actor instance and have the actor start listening to messages that it subscribes to, call "register_actor" on the manager
{{{
mgr.register_actor(SecretActor(), 'secretactor')
}}}
"queue_message" queues an instance of a message in the manager's internal queue to be distributed when the manager "ticks"
{{{
mgr.queue_message(SecretMessage(content='big secret'))
}}}
"tick" first distributes messages to actors, then call actor.update on each actor.  This facilitates an asynchronous call because the message is only distributed later when "tick" is called.
{{{
mgr.tick() # prints "the secret is big secret"
}}}
"trigger" is the synchronous version of the "queue_message" call, it processes the supplied message immediately and does not wait for the actor manager's "tick"
{{{
mgr.trigger(SecretMessage(content='small secret')) # prints "the secret is small secret"
}}}
"find" returns back the instance of the registered actor with that name
{{{
mgr.find('secretactor') # returns the registered actor instance
}}}