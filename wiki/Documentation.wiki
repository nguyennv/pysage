#summary how to use pysage

This tutorial is only applicable to version 1.2.2

For more API documentation, see [http://bigjinfo.com/pysage/ reference]

=Tutorial=
==Automatic Message Packing/Unpacking==
packing can be useful for sending messages across network.  This may prove to be useful in the future when pysage supports cross processing message queuing.
{{{
class MessageToPack(Message):
    properties = ['number']
    packet_type = 101
    def pack_number(self, value):
        return (value.x, value.y)
    def unpack_number(self, value):
        return vector2(value[0], value[1])

# now this message will automatically be stored as a tuple (1,2)
# upon accessing, it will be converted to a vector object transparently
mgr.queue_message(MessageToPack(number=vector2(1,2)))
}}}
==Selective Queuing/Triggering==
sends a particular object a message if that object implements this message type
{{{
mgr.trigger_to_object(self, id, msg)
mgr.queue_message_to_object(self, id, msg)

}}}
==Grouping (Automatic Threads Management)==
Grouping can be very useful in partitioning actors into separate processes.  Actors in different groups have their own independent update/message handling loop.  And messages can be communicated across groups via IPC.  
{{{
class Consumer(MessageReceiver):
    subscriptions = ['SomeWorkDoneMessage']
    packet_type = 102
    def handle_SomeWorkDoneMessage(self, msg):
        pass

class Worker(Actor):
    subscriptions = ['NeedWorkDoneMessage']
    def handle_NeedWorkDoneMessage(self, msg):
        pass
    def update(self, evt):
        '''this automatically gets called in a separate thread per tick'''
        # queuing is strongly advised instead of triggering in multi-threaded environment
        mgr.queue_message(SomeWorkDoneMessage())

}}}
calling "add_process_group" will internally start a separate process for the specified group that all actors that belong to that group will run in
{{{
# in this case, our "worker group"
mgr.add_process_group('worker_group', Worker)
}}}

specify a default actor class for the group so an instance of that actor can be immediately spawned upon group init

{{{
# omitting the group name automatically puts the listener in the main group/thread
mgr.register_object(Consumer(), 'consumer') 

# this puts the "worker" listener in the "worker_group" group/thread
mgr.register_object(Worker(), 'worker', 'worker_group')
}}}
pysage is internally written to be thread-safe.  However, it is only as thread-safe as the user written code (messaging handling, updating, etc).