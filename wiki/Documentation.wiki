#summary how to use pysage
#labels Featured

For more API documentation, see [http://bigjinfo.com/pysage/ reference]

=Tutorial=
==Simple Usage==
This is a line by line explanation of using pysage.  For more advanced usage, skip to the next section.
Here, we import pysage base classes:
{{{
from pysage import Actor, ActorManager
from pysage.messaging import Message
}}}
Next, we will create the actor manager.  Per os process (pysage group), you are guaranteed a single instance of the actor manager.  

The manager instance does all the book-keeping with actors, messages, and communication across processes/networks, so that you don't have to worry about it.  

All you will use it for is to send messages, and manage actors and groups, which we will see later.
{{{
mgr = ActorManager.get_singleton()
}}}
To create a message type, define a class that inherits from "Message".  The "properties" class variable must be defined and is a list of strings.  The list will contain a set of attributes that this type of message will carry.
{{{
class SecretMessage(Message):
    properties = ['content']
}}}
To create an actor type, define a class that inherits from "Actor".  The "subscriptions" class variable of an actor is a list of message type names that the actor will subscribe to.  For each of these message types, the actor class needs to define a method that starts with "handle`_`", and appended with the message type name.  Additionally, the "update" method of each actor will be called each time the actor manager "ticks".  We will talk about the "tick" in a bit.
{{{
class SecretActor(Actor):
    subscriptions = ['SecretMessage']
    def handle_SecretMessage(self, msg):
        print 'the secret is %s' % msg.get_property('content')
        return True # stop propagation
    def update(self):
        '''runs on every mgr.tick'''
        pass
}}}
When you are ready to create an actor instance and have the actor start listening to messages that it subscribes to, call "register_actor" on the manager
{{{
mgr.register_actor(SecretActor(), 'secretactor')
}}}
"queue_message" queues an instance of a message in the manager's internal queue to be distributed when the manager "ticks"
{{{
mgr.queue_message(SecretMessage(content='big secret'))
}}}
"tick" first distributes messages to actors, then call actor.update on each actor.  This facilitates an asynchronous call because the message is only distributed later when "tick" is called.
{{{
mgr.tick() # prints "the secret is big secret"
}}}
"trigger" is the synchronous version of the "queue_message" call, it processes the supplied message immediately and does not wait for the actor manager's "tick"
{{{
mgr.trigger(SecretMessage(content='small secret')) # prints "the secret is small secret"
}}}
"find" returns back the instance of the registered actor with that name
{{{
mgr.find('secretactor') # returns the registered actor instance
}}}
==Automatic Message Packing/Unpacking==
packing can be useful for sending messages across network.  This may prove to be useful in the future when pysage supports cross processing message queuing.
{{{
class MessageToPack(Message):
    properties = ['number']
    packet_type = 101
    def pack_number(self, value):
        return (value.x, value.y)
    def unpack_number(self, value):
        return vector2(value[0], value[1])

# now this message will automatically be stored as a tuple (1,2)
# upon accessing, it will be converted to a vector object transparently
mgr.queue_message(MessageToPack(number=vector2(1,2)))
}}}
==Selective Queuing/Triggering==
sends a particular actor a message if that actor implements this message type
{{{
mgr.trigger_to_actor(self, id, msg)
mgr.queue_message_to_actor(self, id, msg)

}}}
==Grouping (seperate os processes)==
Grouping can be very useful in partitioning actors into separate processes.  Actors in different groups have their own independent update/message handling loop.  And messages can be communicated across groups via IPC.  
{{{
class Consumer(MessageReceiver):
    subscriptions = ['SomeWorkDoneMessage']
    packet_type = 102
    def handle_SomeWorkDoneMessage(self, msg):
        pass

class Worker(Actor):
    subscriptions = ['NeedWorkDoneMessage']
    def handle_NeedWorkDoneMessage(self, msg):
        pass
    def update(self):
        '''this gets called in the "worker_group" process ticks'''
        # queues a message to the main group
        mgr.queue_message_to_group(mgr.PYSAGE_MAIN_GROUP, SomeWorkDoneMessage())

}}}
calling "add_process_group" will internally start a separate process for the specified group that all actors that belong to that group will run in
{{{
# register the consumer in the main group
mgr.register_actor(Consumer())
# in our "worker group", register the Worker actor
mgr.add_process_group('worker_group', Worker)      # spawns a new process that "ticks" independently
}}}

As the second argument to "add_process_group", specify a default actor class for the group so an instance of that actor class can be immediately instantiated upon the group being spawned.

==Network Messages==
Network messages can automatically pack and unpack themselves for purposes of being transported via UDP across the network.  "types" class variable needs to be defined for each message that is intended for network use.
{{{
class SmallMessage(Message):
    properties = ['content']
    types = ['p']
    packet_type = 103

class LargeMessage(Message):
    properties = ['account_numbers']
    types = ['ai']
    packet_type = 104

}}}
besides all the format types supported by python's "struct" module, additional ones are supported by pysage:
|| *Type* || *Description* ||
||"an"||array of arbitrary length of type "n"||
||"S"||a long string of arbitrary size, bigger than 255||