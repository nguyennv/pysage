#summary how to use pysage

For more API documentation, see [http://bigjinfo.com/pysage/ reference]

=Tutorial=
==Automatic Message Packing/Unpacking==
packing can be useful for sending messages across network.  This may prove to be useful in the future when pysage supports cross processing message queuing.
{{{
class MessageToPack(Message):
    properties = ['number']
    packet_type = 101
    def pack_number(self, value):
        return (value.x, value.y)
    def unpack_number(self, value):
        return vector2(value[0], value[1])

# now this message will automatically be stored as a tuple (1,2)
# upon accessing, it will be converted to a vector object transparently
mgr.queue_message(MessageToPack(number=vector2(1,2)))
}}}
==Selective Queuing/Triggering==
sends a particular actor a message if that actor implements this message type
{{{
mgr.trigger_to_actor(self, id, msg)
mgr.queue_message_to_actor(self, id, msg)

}}}
==Grouping (Automatic Threads Management)==
Grouping can be very useful in partitioning actors into separate processes.  Actors in different groups have their own independent update/message handling loop.  And messages can be communicated across groups via IPC.  
{{{
class Consumer(MessageReceiver):
    subscriptions = ['SomeWorkDoneMessage']
    packet_type = 102
    def handle_SomeWorkDoneMessage(self, msg):
        pass

class Worker(Actor):
    subscriptions = ['NeedWorkDoneMessage']
    def handle_NeedWorkDoneMessage(self, msg):
        pass
    def update(self, evt):
        '''this automatically gets called in a separate thread per tick'''
        # queuing is strongly advised instead of triggering in multi-threaded environment
        mgr.queue_message(SomeWorkDoneMessage())

}}}
calling "add_process_group" will internally start a separate process for the specified group that all actors that belong to that group will run in
{{{
# in this case, our "worker group"
mgr.add_process_group('worker_group', Worker)
}}}

As the second argument to "add_process_group", specify a default actor class for the group so an instance of that actor class can be immediately instantiated upon the group being spawned.

==Network Messages==
Network messages can automatically pack and unpack themselves for purposes of being transported via UDP across the network.  "types" class variable needs to be defined for each message that is intended for network use.
{{{
class SmallMessage(Message):
    properties = ['content']
    types = ['p']
    packet_type = 102

class LargeMessage(Message):
    properties = ['account_numbers']
    types = ['ai']
    packet_type = 103

}}}
besides all the format types supported by python's "struct" module, additional ones are supported by pysage:
|| *type* || *description* ||
||"an"||array of arbitrary length of type "n"||
||"S"||a long string of arbitrary size, bigger than 255||